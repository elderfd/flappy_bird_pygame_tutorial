# Game overview
Flappy Bird is a very simple one-button game. The player (a bird) flies at constant speed to the right while avoiding randomly generated obstacles.

The player presses a single button to make the bird move fly upwards slightly. Otherwise the bird falls.

One point is scored for each obstacle the player makes it past.

The game is over if the bird hits an obstacle or the top or bottom of the screen.

# Technology background
Python is a general purpose programming language with a wide range of uses. For this tutorial we will use Python along with a library designed for developing games call PyGame. Very few commercial games (if any) are made with PyGame, but it is a good way of learning the techniques that underly the more common game engines.

For this tutorial you will need to have PyGame installed, which can be done using the python package installer by typing ```pip install pygame``` in your terminal of choice. If this doesn't work, then double check you have Python properly installed.

# This tutorial
This tutorial will attempt to walk you through the production of a simple version of Flappy Bird. Don't feel like you have to stick to the tutorial completely as you go, make the game your own!

There a number of Python files in the repo which show you how the code should roughly look at the end of each stage of development. In the assets folder we also provide all the basic artwork you will need for the game.

To start with, open a new file for your implementation of the game (e.g. `my_game.py`). You can run the game at any time by typing `python my_game.py` (or whatever the name of your file is) in the terminal of your choice.

The code and assets used here were adapted from https://github.com/sourabhv/FlapPyBird. If you wish to add extra features to your game, you may wish to inspect that version of the game.

For brevity some aspects of this code will not represent best practices, but it will suffice for demonstration. A good exercise would be to go through the code after completion and attempt to improve it.

# The basics of a game
Central to all game engines is the concept of the main game loop. This is simply a loop that constantly checks for user input, applies any necessary changes to the game state, and updates the display. In Python code we can write,


```python
keep_game_running = True

while keep_game_running:
    # TODO: Check for user input

    # TODO: Make changes to game

    # TODO: Update the display
```

If you run the above code then you will get an infinite loop as `keep_game_running` is always true (hint: do not run the above code).

So the first thing we will implement is allowing the user to quit the game. To do so we will first add some PyGame-specific set-up. Before the beginning of the loop add the code,

```python
# Sets up the PyGame internals
pygame.init()

# Size of the window
screen_width = 288
screen_height = 512

# Initialise a game window
screen = pygame.display.set_mode((screen_width, screen_height))

# Sets the window title
pygame.display.set_caption("My Flappy Bird")
```

With PyGame properly initialised we will now set up the listener for user input. Within the loop add,

```python
# Checks all pending game events
for event in pygame.event.get():
    if event.type == pygame.QUIT:
        keep_game_running = False
```

In PyGame all user events such as key presses are added to a queue of events. We can access this queue via `pygame.event.get()` and process them as necessary. Currently we only check for the quit event which is generated by clicking the close button on the window.

Your code should now look like the same as `flappy_bird_v1.py`.

Congratulations, you have successfully built the most boring game of "click the close button" in the world!

# Drawing something
While it's nice to have a window that can open and close, we'd also like to draw some exciting artwork onto that window. So we will start by drawing the background for Flappy Bird.

In 2D games one generally works with sprites. These are simply images that are painted onto the screen. Animations can also be handled with sprites; we will return to this later.

We will use a sprite to draw the background for the game. First we must load the sprite from a file. To do so, before the main game loop add,

```python
images = {}
```

This empty Python dictionary will be used to store all of the sprites we will need for the game. Directly after this line add,

```python
images["background"] = pygame.image.load("assets/sprites/background-day.png").convert()
```

This loads the sprite from a file and converts the way in which the image data is stored to match that of the main display. Exactly what this means is unimportant, but it will make your game run faster.

Now we want to draw this sprite onto the window we constructed earlier. Replace the comment `# TODO: Update the display` with,

```python
# Draw the background
screen.blit(
    images["background"],
    (0, 0)
)

# Update the display
pygame.display.update()
```

Blit is simply game engine language for "draw this image", and so the first line draws the sprite we loaded in earlier such that the top-left of the image is at the top-left of the screen.

The pair of numbers set the position that the image is drawn at. In PyGame (and many other graphical systems) the x coordinate (the first of the two numbers) runs from left to right and the y coordinate (the second) runs from top to bottom. Therefore the coordinate `(0, 0)` is at the top-left of the screen. The coordinate `(screen_width, screen_height)` would be at the bottom-right.

The second line updates the screen to show the newly drawn image. This is important as rendering is buffered in PyGame. If this doesn't make sense it doesn't matter too much, but essentially none of your changes to the display will show up until you call the `pygame.display.init` function.

Now if you run your code (as in `flappy_bird_v2.py`) you will get a window proudly displaying the background for Flappy Bird, a clear improvement over the previous state of affairs.

# Adding the bird
What is Flappy Bird without the eponymous hero? As with the background, the bird is drawn by "blitting" a sprite. So after we load the background sprite, we must also load the bird sprite,

```python
images["bird"] = pygame.image.load("redbird-downflap.png").convert_alpha()

# Initial position of the bird
# Bird starts 20% of the way across the screen
# and halfway up the screen
bird_x = int(screen_width * 0.2)
bird_y = int((screen_width - images["bird"].get_height()) / 2)
```

Unlike the background, the bird moves around the screen and so we also construct some variables to store its current position.

Note that when we load the bird sprite we use `convert_alpha` instead of `convert` as when loading the background. This is because this functions maintains the transparency of the image. If you use `convert` instead you will see a coloured rectangle around the bird, showing the limits of the image.

We then update the drawing part of the code to add the bird sprite. Make sure you blit the bird after the background, otherwise it will be covered up.

```python
screen.blit(
    images["bird"],
    (bird_x, bird_y)
)
```

At this point we have a static bird being rendered onto the screen. The next step is to move the bird around the screen. To do this we must track how fast the bird is moving vertically. Initially the bird is not moving at all so the velocity is 0. Add this before the main game loop.

```python
# How much the bird accelerate directly after flap
# Negative because it accelerates toward the top of the screen
bird_flap_acceleration = -15

# Current bird velocity
bird_velocity = 0
```

Velocity can be positive or negative. Due to the coordinate system, negative velocity means the bird is moving upwards and positive means moving downward.

Within the game loop we need to see if the user has pressed the flap button (space) and if so set the bird velocity to the flap velocity.

```python
if event.type == pygame.QUIT:
    keep_game_running = False
elif event.type == pygame.KEYDOWN and (event.key == pygame.K_SPACE):
    bird_acceleration = bird_flap_acceleration   
```

This simply checks if the currently processed event is the pressing of a key and if that key is the space key.

Whenever the bird is not flapping it should be slowly accelerating toward the bottom of the screen. We represent this by making the velocity more positive (more strongly downwards) over time. Before the check for game events we therefore need to set the default acceleration of the bird.

```python
bird_acceleration = acceleration_due_to_gravity
```

And before the whole game loop set the acceleration due to gravity,

```python
acceleration_due_to_gravity = 1
```

Within the game loop but before we draw anything to the screen add,

```python
bird_velocity += bird_acceleration

# Change the y position according to speed
bird_y += bird_velocity
```

We have now added sufficient logic to the game for the bird to move up and down. However if you run the game currently you will probably not see a bird at all! This is because the main game loop runs as fast as possible, and the bird very quickly accelerates off the bottom of the screen. Therefore we are going to limit how quickly the game calculates updates of the bird's position.

In order to do so, we must initialise a clock before the main game loop.

```python
# For stopping the game from rendering too quickly
fps_clock = pygame.time.Clock()

# Max rate of frames
fps = 30
```

We also define the FPS we are aiming for. 30 frames per second is just fast enough for a series of images to be seen as a moving image by the human eye. Now we have the clock set up, at the end of the game loop add,

```python
fps_clock.tick(fps)
```

The clock keeps an internal count of the last time the `tick` function was called. If the time since the last call is smaller than the inverse of (one divided by) the number of frames per second then it will wait until at least that amount of time has passed. By calling this function every time we update the screen, we make sure that the screen does not update faster than our desired number of frames per second.

You might notice that currently the updating of the bird's position and the drawing of the screen are done at the same frequency. Therefore if we increase the FPS the bird will move faster. This is somewhat undesirable, what if we decide we want our screen to update at 60 FPS for a smoother game experience?! This is left as an extension exercise, but the updating of the screen and the calculation of the bird's position can be split apart and controlled by separate timers.

If you run the game now (`flappy_bird_v3.py`) you will have a bird that slowly falls toward the bottom of the screen, but can be made to move upwards by pressing the space bar. The poor bird will however fall off the bottom of the screen if you do not press space enough, we will fix this next.

# Handling the edges of the screen
