# Game overview
Flappy Bird is a very simple one-button game. The player (a bird) flies at constant speed to the right while avoiding randomly generated obstacles.

The player presses a single button to make the bird move fly upwards slightly. Otherwise the bird falls.

One point is scored for each obstacle the player makes it past.

The game is over if the bird hits an obstacle or the top or bottom of the screen.

# Technology background
Python is a general purpose programming language with a wide range of uses. For this tutorial we will use Python along with a library designed for developing games call PyGame. Very few commercial games (if any) are made with PyGame, but it is a good way of learning the techniques that underly the more common game engines.

For this tutorial you will need to have PyGame installed, which can be done using the python package installer by typing ```pip install pygame``` in your terminal of choice. If this doesn't work, then double check you have Python properly installed.

The tutorial was written with Python 3 in mind and tested against that, but should largely work for Python 2 as well.

# This tutorial
This tutorial will attempt to walk you through the production of a simple version of Flappy Bird. Don't feel like you have to stick to the tutorial completely as you go, make the game your own!

There a number of Python files in the repo which show you how the code should roughly look at the end of each stage of development. In the assets folder we also provide all the basic artwork you will need for the game.

To start with, open a new file for your implementation of the game (e.g. `my_game.py`). You can run the game at any time by typing `python my_game.py` (or whatever the name of your file is) in the terminal of your choice.

The code and assets used here were adapted from https://github.com/sourabhv/FlapPyBird. If you wish to add extra features to your game, you may wish to inspect that version of the game.

For brevity some aspects of this code will not represent best practices, but it will suffice for demonstration. A good exercise would be to go through the code after completion and attempt to improve it.

# The basics of a game
Central to all game engines is the concept of the main game loop. This is simply a loop that constantly checks for user input, applies any necessary changes to the game state, and updates the display. In Python code we can write,


```python
keep_game_running = True

while keep_game_running:
    # TODO: Check for user input

    # TODO: Make changes to game

    # TODO: Update the display
```

If you run the above code then you will get an infinite loop as `keep_game_running` is always true (hint: do not run the above code).

So the first thing we will implement is allowing the user to quit the game. To do so we will first add some PyGame-specific set-up. Before the beginning of the loop add the code,

```python
# Sets up the PyGame internals
pygame.init()

# Size of the window
screen_width = 288
screen_height = 512

# Initialise a game window
screen = pygame.display.set_mode((screen_width, screen_height))

# Sets the window title
pygame.display.set_caption("My Flappy Bird")
```

With PyGame properly initialised we will now set up the listener for user input. Within the loop add,

```python
# Checks all pending game events
for event in pygame.event.get():
    if event.type == pygame.QUIT:
        keep_game_running = False
```

In PyGame all user events such as key presses are added to a queue of events. We can access this queue via `pygame.event.get()` and process them as necessary. Currently we only check for the quit event which is generated by clicking the close button on the window.

Your code should now look like the same as `flappy_bird_v1.py`.

Congratulations, you have successfully built the most boring game of "click the close button" in the world!

# Drawing something
While it's nice to have a window that can open and close, we'd also like to draw some exciting artwork onto that window. So we will start by drawing the background for Flappy Bird.

In 2D games one generally works with sprites. These are simply images that are painted onto the screen. Animations can also be handled with sprites; we will return to this later.

We will use a sprite to draw the background for the game. First we must load the sprite from a file. To do so, before the main game loop add,

```python
images = {}
```

This empty Python dictionary will be used to store all of the sprites we will need for the game. Directly after this line add,

```python
images["background"] = pygame.image.load("assets/sprites/background-day.png").convert()
```

This loads the sprite from a file and converts the way in which the image data is stored to match that of the main display. Exactly what this means is unimportant, but it will make your game run faster.

Now we want to draw this sprite onto the window we constructed earlier. Replace the comment `# TODO: Update the display` with,

```python
# Draw the background
screen.blit(
    images["background"],
    (0, 0)
)

# Update the display
pygame.display.update()
```

Blit is simply game engine language for "draw this image", and so the first line draws the sprite we loaded in earlier such that the top-left of the image is at the top-left of the screen.

The pair of numbers set the position that the image is drawn at. In PyGame (and many other graphical systems) the x coordinate (the first of the two numbers) runs from left to right and the y coordinate (the second) runs from top to bottom. Therefore the coordinate `(0, 0)` is at the top-left of the screen. The coordinate `(screen_width, screen_height)` would be at the bottom-right.

The second line updates the screen to show the newly drawn image. This is important as rendering is buffered in PyGame. If this doesn't make sense it doesn't matter too much, but essentially none of your changes to the display will show up until you call the `pygame.display.init` function.

Now if you run your code (as in `flappy_bird_v2.py`) you will get a window proudly displaying the background for Flappy Bird, a clear improvement over the previous state of affairs.

# Adding the bird
What is Flappy Bird without the eponymous hero? As with the background, the bird is drawn by "blitting" a sprite. So after we load the background sprite, we must also load the bird sprite,

```python
images["bird"] = pygame.image.load("redbird-downflap.png").convert_alpha()

# Initial position of the bird
# Bird starts 20% of the way across the screen
# and halfway up the screen
bird_x = int(screen_width * 0.2)
bird_y = int((screen_width - images["bird"].get_height()) / 2)
```

Unlike the background, the bird moves around the screen and so we also construct some variables to store its current position.

Note that when we load the bird sprite we use `convert_alpha` instead of `convert` as when loading the background. This is because this functions maintains the transparency of the image. If you use `convert` instead you will see a coloured rectangle around the bird, showing the limits of the image.

We then update the drawing part of the code to add the bird sprite. Make sure you blit the bird after the background, otherwise it will be covered up.

```python
screen.blit(
    images["bird"],
    (bird_x, bird_y)
)
```

At this point we have a static bird being rendered onto the screen. The next step is to move the bird around the screen. To do this we must track how fast the bird is moving vertically. Initially the bird is not moving at all so the velocity is 0. Add this before the main game loop.

```python
# How much the bird accelerate directly after flap
# Negative because it accelerates toward the top of the screen
bird_flap_acceleration = -15

# Current bird velocity
bird_velocity = 0
```

Velocity can be positive or negative. Due to the coordinate system, negative velocity means the bird is moving upwards and positive means moving downward.

Within the game loop we need to see if the user has pressed the flap button (space) and if so set the bird velocity to the flap velocity.

```python
if event.type == pygame.QUIT:
    keep_game_running = False
elif event.type == pygame.KEYDOWN and (event.key == pygame.K_SPACE):
    bird_acceleration = bird_flap_acceleration   
```

This simply checks if the currently processed event is the pressing of a key and if that key is the space key.

Whenever the bird is not flapping it should be slowly accelerating toward the bottom of the screen. We represent this by making the velocity more positive (more strongly downwards) over time. Before the check for game events we therefore need to set the default acceleration of the bird.

```python
bird_acceleration = acceleration_due_to_gravity
```

And before the whole game loop set the acceleration due to gravity,

```python
acceleration_due_to_gravity = 1
```

Within the game loop but before we draw anything to the screen add,

```python
bird_velocity += bird_acceleration

# Change the y position according to speed
bird_y += bird_velocity
```

We have now added sufficient logic to the game for the bird to move up and down. However if you run the game currently you will probably not see a bird at all! This is because the main game loop runs as fast as possible, and the bird very quickly accelerates off the bottom of the screen. Therefore we are going to limit how quickly the game calculates updates of the bird's position.

In order to do so, we must initialise a clock before the main game loop.

```python
# For stopping the game from rendering too quickly
fps_clock = pygame.time.Clock()

# Max rate of frames
fps = 30
```

We also define the FPS we are aiming for. 30 frames per second is just fast enough for a series of images to be seen as a moving image by the human eye. Now we have the clock set up, at the end of the game loop add,

```python
fps_clock.tick(fps)
```

The clock keeps an internal count of the last time the `tick` function was called. If the time since the last call is smaller than the inverse of (one divided by) the number of frames per second then it will wait until at least that amount of time has passed. By calling this function every time we update the screen, we make sure that the screen does not update faster than our desired number of frames per second.

You might notice that currently the updating of the bird's position and the drawing of the screen are done at the same frequency. Therefore if we increase the FPS the bird will move faster. This is somewhat undesirable, what if we decide we want our screen to update at 60 FPS for a smoother game experience?! This is left as an extension exercise, but the updating of the screen and the calculation of the bird's position can be split apart and controlled by separate timers.

If you run the game now (`flappy_bird_v3.py`) you will have a bird that slowly falls toward the bottom of the screen, but can be made to move upwards by pressing the space bar. The poor bird will however fall off the bottom of the screen if you do not press space enough, we will fix this next.

# Handling the edges of the screen
To make this simple we will assume that the bird can fly as high as it likes (although it will go off the screen). However, if the bird hits the ground then it's game over. To detect this, we will simply check if the bird has descended below a certain height.

We will refactor our code slightly at this point to make it easier to understand and extend later. First at the top of the file, just after we import PyGame add,

```python
class Bird:
    """Holds data about the player bird"""
    def __init__(self, x = 0, y = 0):
        self.x = x
        self.y = y
```

We produce a class here to help us encapsulate all the important information about the bird into one value. If you do not know what a class is, do not worry too much, but you can think of it as a way of defining a new type of variable. This type can contain a selection of its own internal variables and functions. Here we start by defining a `Bird` class with member variables for storing its position.

Where before we defined the x and y position of the bird as separate variables we can now replace this with,

```python
bird = Bird(
    x = int(screen_width * 0.2),
    y = int((screen_width - images["bird"].get_height()) / 2)
)
```

Also go through the code and replace every instance of `bird_y` with `bird.y` and `bird_x` with `bird.x` to match the fact that the coordinates are now stored within the `bird` variable.

Now within the main game loop, just before we update the screen, we check if the bird has crashed,

```python
game_over = has_crashed(bird)
```

Here we are using the `has_crashed` function to determine if the data held within the bird variables indicates a crash. If the bird has crashed then we mark that the game is over. Note that we haven't written the `has_crashed` function yet so this code doesn't yet work. So let's implement that function! After you have defined the height and width of the screen add,

```python
# How high up the screen the ground extends
ground_height = int(screen_height * 0.79)

def has_crashed(bird):
    """Detects if the bird has crashed"""
    return bird.y >= ground_height
```

This is a very simple collision detection, and just checks whether the bird has moved below or touched the ground (remember that a greater y coordinate is further downward in PyGame). There is a slight issue with this code as it stands. With the way we have written the rendering code thus far, the bird is drawn so that the top-left corner of the image sits at the coordinates of the bird. Therefore our `has_crashed` function will only detect when the top-left of the bird passes below the ground. There are a few ways we could fix this but we will opt for changing the rendering of the bird, such that the center of the image is rendered at its coordinates. This means that the bird can slightly overlap with the ground without crashing, but it is a simple fix. Note that if you want to make the collision detection more strict, you could account for the height of the bird image when detecting collision. Change the part of the code that draws the bird to,

```python
screen.blit(
    images["bird"],
    (
        bird.x - images["bird"].get_width() // 2,
        bird.y - images["bird"].get_height() // 2
    )
)
```

Of course we are not currently drawing the ground so the bird will have "crashed" at a seemingly arbitrary height in the game. Let's load the image for the ground at the same place as the other images,

```python
images["ground"] = pygame.image.load('assets/sprites/base.png').convert_alpha()
```

and then draw the ground before we draw the bird,

```python
# Draw the ground
screen.blit(
    images["ground"],
    (0, ground_height)
)
```

Now we are drawing the ground, and detecting if the bird touches it, we need to work out what to do next. To begin with, we will simply end the game and display a game over screen. This is a slightly complex change as we need the main game loop to do one thing if the game is over and another if not. To do so we will use a variable `game_over` to track whether the game has ended yet. If this variable is false the game works as before, if true then it just displays game over.

First load the game_over image,

```python
images["game_over"] = pygame.image.load('assets/sprites/gameover.png').convert_alpha()
```

Then change the main game loop to look like the following,

```python
game_over = False

while keep_game_running:
    bird_acceleration = acceleration_due_to_gravity

    # Checks all pending game events
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            keep_game_running = False
        elif event.type == pygame.KEYDOWN and (event.key == pygame.K_SPACE) and not game_over:
            bird_velocity = bird_flap_acceleration             

    if not game_over:
        bird_velocity += bird_acceleration

        # Change the y position according to speed
        bird.y += bird_velocity

        game_over = has_crashed(bird)

    # Draw the background
    screen.blit(
        images["background"],
        (0, 0)
    )

    # Draw the ground
    screen.blit(
        images["ground"],
        (0, ground_height)
    )

    screen.blit(
        images["bird"],
        (
            bird.x - images["bird"].get_width() // 2,
            bird.y - images["bird"].get_height() // 2
        )
    )

    if game_over:
        screen.blit(
            images["game_over"],
            (
                (screen_width - images["game_over"].get_width()) // 2,
                (screen_height - images["game_over"].get_height()) // 2,
            )
        )

    # Update the display
    pygame.display.update()
    fps_clock.tick(fps)

```

We have made a large number of changes to the code in this section so I strongly recommend reading `flappy_bird_v4.py` to make sure you didn't miss anything. You now have Flappy Bird without the obstacles, we are getting close!

# Adding the obstacles
As the game currently stands we have no way of scoring points and no obstacles to avoid. We will add both of those in this section. First we will work with obstacles.

As before we load images for our new game objects. Pipes come from both the top and bottom of the screen so we also make an inverted copy,

```python
# Load pipe image twice, the second time invert it
images["pipe_up"] = pygame.image.load('assets/sprites/pipe-green.png').convert_alpha()
images["pipe_down"] = pygame.transform.rotate(
    pygame.image.load('assets/sprites/pipe-green.png').convert_alpha(),
    180
)
```

Similar to how we refactored the handling of bird data, we make a `Pipe` class,

```python
import random
from enum import Enum

class Pipe:
    """Holds info about an obstacle pipe"""
    class Direction(Enum):
        UP = 0
        DOWN = 1

    def __init__(self, x = 0, y = 0, direction = Direction.UP):
        self.x = x
        self.y = y
        self.direction = direction

    @staticmethod
    def generate_random_pair(initial_x):
        gap_size = 125

        start_of_gap = random.randrange(
            int(screen_height * 0.2),
            int(screen_height * 0.8 - gap_size)
        )

        pipe_height = images["pipe_down"].get_height()

        # Return a pair of pipes to match the generated gap
        return (
            Pipe(initial_x, start_of_gap + gap_size, Pipe.Direction.UP),
            Pipe(initial_x, start_of_gap - pipe_height, Pipe.Direction.DOWN)
        )
```

The inner class Direction is the pythonic way of generating an enumeration (enum). This simply a neat way of defining a type that can have one of a few distinct values, in this case `Direction.UP` and `Direction.DOWN`. `x` and `y` have the same meaning as for the bird, and `direction` tells us whether the pipe is coming from the top or bottom of the screen.

The final piece is the static method for generating a pair of random pipes. Static simply means that this function is not tied to any particular instance of the class. In other words each variable of type `Pipe` has its own `x` and `y` but the function `generate_random_pair` is attached to the class itself. If this makes no sense, do not worry too much.

In order to position the gap between the pipes randomly we make use of the `randrange` function from the `random` package. Every time you call this function you will get a different (random uniformly-distributed) integer between the first (inclusive) and second (exclusive) argument.

The function simply returns a tuple containing the upper and lower pipe to match the randomly-positioned gap.

Now we have a way of generating and storing pipes, let's add some! Before the main game loop add,

```python
# Stores info about all currently existing pipes
pipes = []

# Generate some initial pipes just off the screen
pipes += list(Pipe.generate_random_pair(screen_width + 10))
```

And after you draw the ground in the loop add,

```python
for pipe in pipes:
    screen.blit(
        images["pipe_up"] if pipe.direction == Pipe.Direction.UP else images["pipe_down"],
        (pipe.x, pipe.y)
    )   
```

Notice how we use an inline `if else`. This is not always very readable but I like it in this case. If you haven't seen it before then

```python
result = "a" if something else "b"
```

is shorthand for,

```python
if something:
    result = "a"
else:
    result = "b"
```

 If you run the game now you will see the first random pair of pipes generated. Let's make those pipes move toward the bird. Yes, counterintuitively we will keep the bird in a fixed position and move the pipes toward it. The reasoning behind this is beyond the scope of the tutorial, but trust me that it makes things a bit easier. Just after we change the bird position (`bird.y += bird_velocity`) add,

```python
for pipe_index, pipe in enumerate(pipes):
    pipe.x += pipe_velocity
```

and define the velocity of pipe movement before the main game loop,

```python
# How quickly the pipes move across the screen
pipe_velocity = -5
```

We are iterating through the list of existing pipes and moving them toward the bird at a fixed rate. Note our use of `enumerate`. This is very useful bit of Python. `enumerate` wraps around an `Iterable` such as a list, and when it is iterated through (e.g. used in a `for` loop) it yields a pair. The first element of the pair is the 0-based index of the element and the second is the element. As an example,

```python
for letter in ["a", "b", "c"]:
    print(letter)

# Prints:
# "a"
# "b"
# "c"

for index, letter in enumerate(["a", "b", "c"]):
    print(index, letter)

# Prints:
# 0, "a"
# 1, "b"
# 2, "c"
```

In our case we do not use the `pipe_index` straight away but it is useful for the next part.

As the code stands, the initial pipes will now move toward the bird. However eventually they will move off the screen and never be seen again, which isn't very useful. Let's set up the code to add some more pipes as those first two disappear. Directly after our previous bit of code (within the `for` loop over `pipes`) add,

```python
# If pipes are almost off the screen generate some more
# Only check the up pipes to avoid duplication
if pipe.x < 100 and pipe.x > 95 and pipe.direction == Pipe.Direction.UP:
    pipes += list(Pipe.generate_random_pair(screen_width + 10))
```

This simply generates a new pair of pipes in the same way we made the first two, and adds them to the list of pipes. Now your game has multiple sets of pipes to avoid! However we never delete any pipes. Although they are off the screen, the game still has to store their data and keeping them moving ever leftward. Therefore let's tidy up the pipes that leave the screen. Directly after the previous piece of code add,

```python
# If the pipe is off the screen, mark it for removal
if pipe.x < -pipe_width:
    pipes_to_remove.append(pipe_index)
```

And before the loop over pipes create an empty list to store the indices of which pipes we must delete,

```python
pipes_to_remove = []
```

Finally after the loop over `pipes` add,

```python
# Remove excess pipes
for pipe_index in reversed(pipes_to_remove):
    pipes = pipes[:pipe_index] + pipes[pipe_index:]
```

`reversed` is similar to `enumerate` in that it wraps an `Iterable`. However in this case instead of adding extra information, it reverses the `Iterable`. We remove the pipes marked for removal in reverse order using the Python slice syntax. Slicing with `[:pipe_index]` gives us every element up until `pipe_index` and with `[pipe_index:]` gives us every element after. So this rather effectively returns the same list but with the element at `pipe_index` missing. You might want to think about why we need to reverse this list before removing anything.

So we now have an infinite number of pipes to avoid, however the bird can happily fly through the pipes without any problems. Let's fix that.

This is perhaps overkill for our case but we are going to implement a more complex form of collision detection by hand. If this part doesn't make sense, don't worry too much. PyGame can actually handle this for you (and probably more efficiently), but it's nice to understand how it works. If you're interested then read on in detail, otherwise copy and paste as appropriate.

Somewhere near the top of the file we define a handy utility class,

```python
class Collider:
    def __init__(self, image):
        self.rect = pygame.Rect(0, 0, image.get_width(), image.get_height())
        self.mask = [
            [bool(image.get_at((j, i))[3]) for j in range(image.get_width())]
            for i in range(image.get_height())
        ] 

    def set_coords(self, x, y):
        """Moves the collider to the coordinates"""
        self.rect.x = x
        self.rect.y = y

    def collides_with(self, other):
        """Checks if two colliders collide"""
        # Get the intersection of the two rects
        intersect_rect = self.rect.clip(other.rect)

        # If no intersection then definitely do not collide
        if intersect_rect.width == 0 or intersect_rect.height == 0:
            return False

        # Get offsets for two rects
        x1, y1 = intersect_rect.x - self.rect.x, intersect_rect.y - self.rect.y
        x2, y2 = intersect_rect.x - other.rect.x, intersect_rect.y - other.rect.y

        # Check if masks overlap
        for i in range(intersect_rect.width):
            for j in range(intersect_rect.height):
                if self.mask[j + y1][i + x1] and other.mask[j + y2][i + x2]:
                    return True
        
        return False
```

There is a lot going on here and I won't explain in too much detail. At its simplest what we are doing is defining a class that contains a rectangle and a mask. Instances of this class are built by providing a image (e.g. the image of the bird we loaded in from a file). It stores a bounding box (the rectangle) which defines how large the image is. We also move the coordinates (x and y) of the bounding box to match the position of the image on the screen.

The mask we store is simply a 2D grid storing integers. We have a grid cell for every pixel in the image. The value at the grid cells is 1 when the pixel represented is opaque (i.e. not transparent) and 0 otherwise. This is a simple way of storing where in the image there is an object and where there is empty space. We need to do this as all images are rectangular, and we do not want empty space in the bird image (e.g. the corners) to collide with the pipes.

The `collides_with` function is used to compare two objects of type `Collider` and return whether they are colliding or not. First we check whether the bounding boxes (the rectangles) overlap. This is very quick to do, and let's us know whether there's any chance at all that the two images the colliders were made from are overlapping. If the bounding boxes overlap we then make a much more expensive (in terms of calculation time) comparison of the two masks. This lets us check whether the images overlap such that two parts of the objects are overlapping, and not just empty space.

With the `Collider` class ready to go we now make some colliders for the pipes and the bird. After the images are loaded in add,

```python
# Colliders for obstacles and player
colliders = {
    "bird": Collider(images["bird"]),
    "pipe_up": Collider(images["pipe_up"]),
    "pipe_down": Collider(images["pipe_down"])
}
```

We are now set up to actually check for collisions. We go back to our old `has_crashed` function and change it to read,

```python
def has_crashed(bird, pipes):
    """Detects if the bird has crashed"""
    # Check if bird has hit the ground    
    if bird.y >= ground_height:
        return True

    # Check collision between pipes and bird
    bird_collider = colliders["bird"]

    # Use offset to account for the fact that the bird
    # x and y are at the centre of the image
    bird_collider.set_coords(
        bird.x - images["bird"].get_width() // 2,
        bird.y - images["bird"].get_height() // 2
    )

    for pipe in pipes:
        pipe_collider = colliders["pipe_up"] if pipe.direction == Pipe.Direction.UP else colliders["pipe_down"]

        pipe_collider.set_coords(pipe.x, pipe.y)
        
        if pipe_collider.collides_with(bird_collider):
            return True

    return False
```

Notice that we now pass it the list of pipes as well, so make sure you change the use of the function later in the script to read `has_crashed(bird, pipes)` as well.

The first check in this function is the same test we were doing for hitting the ground. After that we make sure the coordinates of our previously generated colliders match the position of the bird and pipes, and check for collisions there.

This part was very complex so definitely check `flappy_bird_v5.py`.

You now have almost all the elements of Flappy Bird. The only thing missing is a sense of accomplishment, let's add scores!

# Adding scores

# Extensions
Now you have a simple but working version of Flappy Bird! Congratulations! If you've enjoyed the tutorial so far, why not try adding your extensions or customising the game. Here are some suggestions,

- Scrolling background.
- Difficulty levels (e.g. movement speed, gap size).
- A leaderboard.
- Custom graphics.
- Take a look at the pygame.sprite package and notice that we've actually implemented some things by hand that PyGame could have done for us. Convert the code to make use of this.